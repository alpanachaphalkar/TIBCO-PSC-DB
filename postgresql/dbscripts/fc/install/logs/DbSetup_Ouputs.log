---------------------------------------------------
Using PGHOME=
Using PGSQL=/bin/psql
Using PGPORT=
Using PGPORT=
Using PGDATABASE=
Using PGUSER=
---------------------------------------------------
---------------------------------------------------
Using PGHOME=
Using PGSQL=/bin/psql
Using PGPORT=
Using PGPORT=
Using PGDATABASE=
Using PGUSER=
---------------------------------------------------
---------------------------------------------------
Using PGHOME=
Using PGSQL=/bin/psql
Using PGPORT=
Using PGPORT=
Using PGDATABASE=
Using PGUSER=
---------------------------------------------------
---------------------------------------------------
Using PGHOME=/usr/lib/postgresql/10
Using PGSQL=/usr/lib/postgresql/10/bin/psql
Using PGPORT=35.200.217.131
Using PGPORT=5432
Using PGDATABASE=velodb
Using PGUSER=mdmuser
---------------------------------------------------
DO LANGUAGE plpgsql $$ 
DECLARE
 FUNC_ID smallint;
BEGIN
	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_sync';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_sync', 'FP Catalog Synchronization', 'catalogmenu_catalog_sync');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_publish';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_publish', 'Publish Catalog', 'catalogmenu_catalog_publish');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_fc_export';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_fc_export', 'Export FC Data', 'catalogmenu_catalog_fc_export');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_fc_import';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_fc_import', 'Import FC Data', 'catalogmenu_catalog_fc_import');
	END IF;
	
	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_bulk_delete';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_bulk_delete', 'Bulk Delete', 'catalogmenu_catalog_bulk_delete');
	END IF;	
	
END;
$$;
DO
/* Data for the `SCREEN` table  (Records 2001-...) */
DO LANGUAGE plpgsql $$ 
DECLARE
 SCREEN_ID smallint;
BEGIN
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '2001';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('2001', 'EN', 'FP Catalog Synchronization', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1102';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1102', 'EN', 'Publish Catalog', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1103';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1103', 'EN', 'Publish Catalog Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1104';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1104', 'EN', 'Export FC Data Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1105';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1105', 'EN', 'Import FC Data', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1106';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1106', 'EN', 'Import FC Data Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1107';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1107', 'EN', 'Export FC Data', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1111';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1111', 'EN', 'Hierarchy Management', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1113';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1113', 'EN', 'Delta Import', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1114';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1114', 'EN', 'Bulk Delete', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1115';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1115', 'EN', 'Bulk Delete Status', NULL);
	END IF;	
END;
$$;
DO
DROP TYPE IF EXISTS T_RELEXTRACTOR_REC CASCADE;
DROP TYPE
DROP TYPE IF EXISTS T_COLUMNNAMES CASCADE;
DROP TYPE
DROP TYPE IF EXISTS T_EXTRACT_REC CASCADE;
DROP TYPE
CREATE TYPE T_RELEXTRACTOR_REC AS (
    relid NUMERIC(19),
	reltype NUMERIC(19)
);
CREATE TYPE
CREATE TYPE T_COLUMNNAMES AS(
	columnName VARCHAR(30)
);
CREATE TYPE
CREATE TYPE T_EXTRACT_REC AS(
	productKeyId BIGINT,
	catalogId BIGINT,
	modVersion BIGINT
);
CREATE TYPE
CREATE OR REPLACE FUNCTION fc_del_from_dbe_relationship(orgid bigint, reltablename character varying, mastertablename character varying, fromtimestamp character varying, totimestamp character varying)
  RETURNS void AS
$BODY$
	DECLARE 
		parent_id RELATIONSHIP.PARENTID%TYPE;
		parent_Version RELATIONSHIP.PARENTVERSION%TYPE;
		child_id RELATIONSHIP.CHILDID%TYPE;
		child_Version RELATIONSHIP.CHILDVERSION%TYPE;
		mod_date RELATIONSHIP.MODDATE%TYPE;
		
		previousModDate RELATIONSHIP.MODDATE%TYPE;
		previousRelationId DECIMAL(38) = NULL;
		
		rctTableName CATALOG.TABLENAME%TYPE;
		childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
		parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
		
		columnDataCount SMALLINT;
		
		l_relextractor T_RELEXTRACTOR_REC;
		l_columnanmes T_COLUMNNAMES;
		
		to_delete T_EXTRACT_REC [];
		to_retain T_EXTRACT_REC [];
	
		to_delete_counter INTEGER := 1;
		to_retain_counter INTEGER := 1;
	
		retain_flag BOOLEAN :=false;
		delete_flag BOOLEAN :=true;
  
		counter INTEGER := 0;

		to_delete_rec T_EXTRACT_REC;
		to_retain_rec T_EXTRACT_REC;
		
		hasDataChanged varchar(1);
		
	BEGIN
		FOR l_relextractor IN EXECUTE  'SELECT RELID, TYPE FROM ' || relTablename LOOP
			BEGIN
				hasDataChanged := 'N';
				delete_flag := false;
      
				
				SELECT DISTINCT 'rct_' || RELATIONSHIPCATALOGID  FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE = l_relextractor.reltype  AND ACTIVE = 'Y'  INTO rctTableName;
					
				SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
							ELSE TEMP.TARGETCATALOGID 
						END INTO childCatalogId FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relextractor.reltype AND ACTIVE = 'Y') TEMP;

				SELECT DISTINCT OWNERID INTO parentCatalogId FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relextractor.reltype AND ACTIVE = 'Y';

				SELECT PARENTID, PARENTVERSION, CHILDID, CHILDVERSION ,MODDATE INTO parent_id, parent_Version, child_id, child_Version,mod_date FROM RELATIONSHIP WHERE RELATIONID = l_relextractor.relid;
				IF mod_date >= to_timestamp(fromtimestamp,'YYYY-MM-DD HH24:mi:ss:MS') AND mod_date <= to_timestamp(totimestamp,'YYYY-MM-DD HH24:mi:ss:MS') THEN
				
					EXECUTE 'SELECT MAX(MODDATE) FROM RELATIONSHIP,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') PARENT,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') CHILD        WHERE PARENTID = ' || parent_id || ' AND CHILDID = ' || child_id || ' AND TYPE = ' || l_relextractor.reltype || ' AND MODDATE < to_timestamp(''' || mod_date || ''',''YYYY-MM-DD HH24:mi:ss:MS'') AND ACTIVE = ''Y'' AND PARENTID = PARENT.PRODUCTKEYID AND PARENTVERSION = PARENT.MODVERSION AND CHILDID = CHILD.PRODUCTKEYID AND CHILDVERSION = CHILD.MODVERSION' INTO previousModDate;	

					RAISE NOTICE 'previousModDate--%',previousModDate;
					
					IF previousModDate IS NOT NULL THEN
					
						EXECUTE 'SELECT RELATIONSHIP.RELATIONID FROM RELATIONSHIP,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') PARENT,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') CHILD        WHERE PARENTID = ' || parent_id || ' AND CHILDID = ' || child_id || ' AND TYPE = ' || l_relextractor.reltype || ' AND MODDATE = to_timestamp(''' || previousModDate || ''',''YYYY-MM-DD HH24:mi:ss:MS'') AND ACTIVE = ''Y'' AND PARENTID = PARENT.PRODUCTKEYID AND PARENTVERSION = PARENT.MODVERSION AND CHILDID = CHILD.PRODUCTKEYID AND CHILDVERSION = CHILD.MODVERSION' INTO previousRelationId;
					
						RAISE NOTICE 'previousRelationId--%',previousRelationId;
					
					
						IF previousRelationId IS NOT NULL THEN
							FOR l_columnanmes IN EXECUTE  'SELECT COLUMN_NAME FROM information_schema.columns WHERE TABLE_NAME = ''' || rctTableName || '''' LOOP
								BEGIN
									IF l_columnanmes.columnName != 'CRELATIONID' AND l_columnanmes.columnName != 'crelationid'  THEN
										
										EXECUTE  'SELECT COUNT(*) FROM (SELECT DISTINCT ' || l_columnanmes.columnName || ' FROM ' || rctTableName || ' WHERE CRELATIONID IN (' || l_relextractor.relid || ',' || previousRelationId || ')) COLUMNNAMEALIAS' INTO columnDataCount;
            
										IF columnDataCount > 1 THEN
											RAISE NOTICE 'l_columnanmes.columnName%',l_columnanmes.columnName;
											hasDataChanged := 'Y';
										END IF;
									END IF;
								END;
							END LOOP;
						
							IF hasDataChanged = 'N' THEN
								RAISE NOTICE 'Deleting relationid--%',  l_relextractor.relid;
								EXECUTE  'DELETE FROM ' || relTablename || ' WHERE RELID = ' || l_relextractor.relid;

								to_delete_rec.productKeyId := parent_id;
								to_delete_rec.catalogId := parentCatalogId;
								to_delete_rec.modVersion := parent_Version;
								
								to_delete[to_delete_counter] := to_delete_rec;
								to_delete_counter := to_delete_counter+1;
							       
								to_delete_rec.productKeyId := child_id;
								to_delete_rec.catalogId := childCatalogId;
								to_delete_rec.modVersion := child_Version;
								
								to_delete[to_delete_counter] := to_delete_rec;
								to_delete_counter := to_delete_counter+1;

								delete_flag := true;
							END IF;
						END IF;
					
					
						IF not found then
							raise notice 'No data found';
						END IF;
					END IF;
				
				ELSE
					RAISE NOTICE 'deleting relationid--%',  l_relextractor.relid;
					
					EXECUTE  'DELETE FROM ' || relTablename || ' WHERE RELID = ' || l_relextractor.relid;
		   
					to_delete_rec.productKeyId := parent_id;
					to_delete_rec.catalogId := parentCatalogId;
					to_delete_rec.modVersion := parent_Version;
								
					to_delete[to_delete_counter] := to_delete_rec;
					to_delete_counter := to_delete_counter+1;
								
					to_delete_rec.productKeyId := child_id;
					to_delete_rec.catalogId := childCatalogId;
					to_delete_rec.modVersion := child_Version;

					to_delete[to_delete_counter] := to_delete_rec;
					to_delete_counter := to_delete_counter+1;
								
					delete_flag := true;
				END IF;
			
				IF NOT delete_flag THEN 
					to_retain_rec.productKeyId := parent_id;
					to_retain_rec.catalogId := parentCatalogId;
					to_retain_rec.modVersion := parent_Version;

					to_retain[to_retain_counter] := to_retain_rec;
					to_retain_counter := to_retain_counter+1;

					
					to_retain_rec.productKeyId := child_id;
					to_retain_rec.catalogId := childCatalogId;
					to_retain_rec.modVersion := child_Version;
					
					to_retain[to_retain_counter] := to_retain_rec;
					to_retain_counter := to_retain_counter+1;
				END IF;
			END;
		END LOOP;

		IF to_delete[1] IS NOT NULL THEN
		
			FOR j IN 1..array_upper(to_delete, 1) LOOP
				BEGIN       
					IF to_retain[1] IS NOT NULL THEN
						FOR k IN 1..array_upper(to_retain, 1) LOOP
							BEGIN
								IF to_delete[j].productKeyId = to_retain[k].productKeyId  AND to_delete[j].catalogId = to_retain[k].catalogId THEN
									retain_flag :=true;
									EXIT WHEN retain_flag;
								END IF;
							END;
						END LOOP;
					END IF;
	
      
					IF NOT retain_flag THEN
						Raise notice 'masterTableName--%--%',masterTableName,to_delete[j];
						EXECUTE  'DELETE FROM ' || masterTableName || to_delete[j].catalogId || ' WHERE PRODUCTKEYID = ' ||  to_delete[j].productKeyId || ' AND MODVERSION = ' || to_delete[j].modVersion|| ' AND PRODUCTKEYID NOT IN (SELECT PRODUCTKEYID FROM PRINCIPALKEY WHERE PRODUCTKEYID = ' || to_delete[j].productKeyId || ' AND ACTIVE = ''Y'' AND STATE = ''CONFIRMED'' AND MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss:MS'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss:MS''))';
					END IF;
         
					retain_flag :=false; 
				END;
			END LOOP;
		END IF;
	END;	
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
DROP TYPE IF EXISTS T_DELETED_RELS CASCADE;
DROP TYPE
CREATE  TYPE T_DELETED_RELS AS(
	parentId VARCHAR(255),
	parentIdExt VARCHAR(255),
	parentCatalogName VARCHAR(80),
	childId VARCHAR(255),
	childIdExt VARCHAR(255),
	childCatalogName VARCHAR(80),
	relationshipName VARCHAR(80)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION fc_get_deleted_relationship(IN orgid bigint, IN fromtimestamp character varying, IN totimestamp character varying, OUT deletedrels t_deleted_rels[])
  RETURNS t_deleted_rels[] AS
$BODY$
DECLARE

	parentid RELATIONSHIP.PARENTID%TYPE;
	childid RELATIONSHIP.CHILDID%TYPE;
	
	childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	
	parentCatalogName CATALOG.NAME%TYPE;
	childCatalogName CATALOG.NAME%TYPE;
  
	productId varchar(255);
	productIdExt varchar(255);
  
	relationshipName RELATIONSHIPDEFINITION.NAME%TYPE;
  
	columnDataCount SMALLINT;
	sQuery text;
	l_deletedRelationships RELATIONSHIP%ROWTYPE;
	deletedRel T_DELETED_RELS;
	k integer := 1;
BEGIN

    deletedRel.parentId :='parentId';
	deletedRel.parentIdExt :='parentIdExt';
	deletedRel.parentCatalogName :='parentCatalogName';
	deletedRel.childId :='childId';
	deletedRel.childIdExt :='childIdExt';
	deletedRel.childCatalogName :='childCatalogName';
	deletedRel.relationshipName :='relationshipName';
	deletedrels[k] :=deletedRel;
	k := k+1;
	
	IF fromtimestamp = NULL OR TRIM(fromtimestamp) = '' THEN
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE <= to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.ACTIVE = ''N'' 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'')';
	ELSE
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.ACTIVE = ''N'' 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'')';
	END IF;
	
	FOR l_deletedRelationships IN EXECUTE sQuery LOOP
		BEGIN
			RAISE NOTICE '%',k;
			SELECT DISTINCT RELATIONSHIPDEFINITION.OWNERID, CATALOG.NAME INTO parentCatalogId, parentCatalogName FROM RELATIONSHIPDEFINITION, CATALOG 
			WHERE RELATIONSHIPDEFINITION.ORGANIZATIONID = orgId AND RELATIONSHIPDEFINITION.TYPE = l_deletedRelationships.TYPE AND RELATIONSHIPDEFINITION.ACTIVE = 'Y'
			AND RELATIONSHIPDEFINITION.OWNERID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			RAISE NOTICE '%',parentCatalogId;
			RAISE NOTICE '%',l_deletedRelationships.PARENTID;
			RAISE NOTICE '%',l_deletedRelationships.PARENTVERSION;
			
			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.PARENTID  || ' AND CMODVERSION = ' || l_deletedRelationships.PARENTVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.PARENTID || ' AND CMODVERSION = ' || l_deletedRelationships.PARENTVERSION  INTO productIdExt ;
			

		
			RAISE NOTICE '%',productId;
			RAISE NOTICE '%',productIdExt;
			deletedRel.parentId := productId;
			deletedRel.parentIdExt := productIdExt;
			deletedRel.parentCatalogName := parentCatalogName;

				SELECT DISTINCT TEMP1.CATID, CATALOG.NAME INTO childCatalogId, childCatalogName FROM CATALOG, 
			(SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
						ELSE TEMP.TARGETCATALOGID 
					END CATID FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_deletedRelationships.TYPE AND ACTIVE = 'Y') TEMP) TEMP1
			WHERE TEMP1.CATID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.CHILDID  || ' AND CMODVERSION = ' || l_deletedRelationships.CHILDVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.CHILDID || ' AND CMODVERSION = ' || l_deletedRelationships.CHILDVERSION  INTO productIdExt ;
			
			deletedRel.childId := productId;
			deletedRel.childIdExt := productIdExt;
			deletedRel.childCatalogName := childCatalogName;

			SELECT NAME INTO relationshipName FROM RELATIONSHIPDEFINITION WHERE TYPE = l_deletedRelationships.TYPE AND ACTIVE = 'Y';

			deletedRel.relationshipName := relationshipName;
			deletedRels[k]=deletedRel;
			k:=k+1;
		END; 
		     
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
drop trigger IF EXISTS FC_TU_PROCESS ON PROCESS;
DROP TRIGGER
CREATE OR REPLACE FUNCTION updateworkitem()
  RETURNS trigger AS
$BODY$DECLARE
   processId_ PROCESS.ID%TYPE;
   plCount BIGINT;
BEGIN 
   processId_ := OLD.ID;

   SELECT COUNT(*) INTO plCount FROM PROCESSLOG WHERE PROCESSID = processId_ AND LOWER(ACTION) = 'fcextractdatatodelimitedfile';
   
   IF plCount > 0 THEN
   
       NEW.status := 'WAIT-TASK';
       
   END IF;

  RETURN NEW;
    
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
CREATE TRIGGER FC_TU_PROCESS BEFORE UPDATE OF STATUS ON PROCESS 
FOR EACH ROW WHEN (NEW.STATUS = 'WAIT-WORKITEM') EXECUTE PROCEDURE updateworkitem();
CREATE TRIGGER
CREATE OR REPLACE FUNCTION fc_updatelifecyclestatus_pkg_get_record(witemid character varying)
  RETURNS void AS
$BODY$
DECLARE 

	catalogId WORKITEMDETAIL.VALUE%TYPE;
	productKeyId WORKITEMDETAIL.VALUE%TYPE;
	productVersion WORKITEMDETAIL.VALUE%TYPE;
	recordCount DECIMAL(10);
	sQuery VARCHAR(1000);
	sPreviousStatus VARCHAR(100);
BEGIN
		
	SELECT WORKITEMDETAIL.VALUE INTO catalogId FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND WORKITEMDETAIL.NAME = 'MASTERCATALOGID';
						
	SELECT WORKITEMDETAIL.VALUE INTO productKeyId FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'PRODUCTKEYID';
				
	SELECT WORKITEMDETAIL.VALUE INTO productVersion FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'PRODUCTVERSION';


	
	EXECUTE 'SELECT clifecyclestatus as varchar FROM MCT_' || catalogId || ' WHERE CPRODUCTKEYID = ' || to_number(productKeyId) || ' AND CMODVERSION = ' || to_number(productVersion)  INTO sPreviousStatus;
	  
	IF sPreviousStatus IS NULL OR TRIM(sPreviousStatus) = '' THEN
		sPreviousStatus := 'TESTING';
	END IF;
  
	DELETE FROM LIFECYCLE_STATUS WHERE CPRODUCTKEYID = to_number(productKeyId);
	INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (to_number(productKeyId), sPreviousStatus , CURRENT_TIMESTAMP);
	INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (to_number(productKeyId), 'PENDINGAPPROVAL' , CURRENT_TIMESTAMP);  
	
	EXECUTE 'UPDATE MCT_' || catalogId || ' SET CLIFECYCLESTATUS = ''PENDINGAPPROVAL'' WHERE CPRODUCTKEYID = ' || to_number(productKeyId) || ' AND CMODVERSION = ' || to_number(productVersion) ;
	
	SELECT WORKITEMDETAIL.VALUE INTO recordCount FROM WORKITEM, WORKITEMDETAIL 
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'RECORD_COUNT';
	
	IF recordCount > 1 THEN
		PERFORM FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(productKeyId, productVersion,catalogId);
	END IF;
END;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;
CREATE FUNCTION
DROP TYPE IF EXISTS T_CHILDRECORDS CASCADE;
DROP TYPE
CREATE  TYPE T_CHILDRECORDS AS(
	childid varchar(4000),
    childVersion varchar(4000)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION  FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(productKeyId IN WORKITEMDETAIL.VALUE%TYPE, productVersion IN WORKITEMDETAIL.VALUE%TYPE, catalogId IN WORKITEMDETAIL.VALUE%TYPE) RETURNS VOID AS
$BODY$
DECLARE 
    l_children T_CHILDRECORDS;
    sQuery VARCHAR(1000);
    sPreviousStatus VARCHAR(100);
BEGIN

	FOR l_children IN EXECUTE 'SELECT CHILDID, CHILDVERSION FROM RELATIONSHIP WHERE PARENTID =' || productKeyId || 'AND PARENTVERSION =' || productVersion || 'AND OWNERID =' || catalogId || 'AND CHILDOWNERID = '|| catalogId LOOP
		
		EXECUTE 'SELECT clifecyclestatus as varchar FROM MCT_' || catalogId || ' WHERE CPRODUCTKEYID = ' || l_children.childid || ' AND CMODVERSION = ' || l_children.childVersion INTO sPreviousStatus;
				
			IF sPreviousStatus IS NULL OR TRIM(sPreviousStatus) = '' THEN
				sPreviousStatus := 'TESTING';
			END IF;		
		  
			DELETE FROM LIFECYCLE_STATUS WHERE CPRODUCTKEYID = l_children.childid;
			INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (l_children.childid, sPreviousStatus , CURRENT_TIMESTAMP);
			INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (l_children.childid, 'PENDINGAPPROVAL' , CURRENT_TIMESTAMP);
		
		EXECUTE 'UPDATE MCT_' || catalogId || ' SET CLIFECYCLESTATUS = ''PENDINGAPPROVAL'' WHERE CPRODUCTKEYID = ' || l_children.childid || ' AND CMODVERSION = ' || l_children.childVersion;
		PERFORM FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(l_children.childid, l_children.childVersion, catalogId);
	END LOOP;

END;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION ClearNamedVersionData(ORG_NAME varchar(80)) RETURNS VOID AS $$
	DECLARE
		idOrganization ORGANIZATION.ID%TYPE;
	BEGIN
	
		RAISE NOTICE 'Organization Name:%',ORG_NAME;
		SELECT ID INTO idOrganization FROM ORGANIZATION WHERE lower(name) = lower(ORG_NAME);
		RAISE NOTICE 'Enterprise Id:%',idOrganization;

		DELETE FROM NAMEDVERSION WHERE OWNERID IN (SELECT ID FROM CATALOG WHERE SOURCEORGANIZATIONID = idOrganization AND TYPE = 'CATALOG' AND ACTIVE = 'Y');
		DELETE FROM NAMEDVERSION WHERE OWNERID = idOrganization;
	
		IF NOT FOUND THEN
			RAISE NOTICE 'No data found';
		END IF;
	END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
DROP TYPE IF EXISTS T_RELS CASCADE;
DROP TYPE
CREATE TYPE T_RELS AS(
	parentId VARCHAR(255),
	parentIdExt VARCHAR(255),
	parentVersion bigint,
	parentCatalogName VARCHAR(80),
	childId VARCHAR(255),
	childIdExt VARCHAR(255),
	childVersion bigint,
	childCatalogName VARCHAR(80),
	relationshipName VARCHAR(80)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION FC_GET_REL_DEL_MOD_IN_TS(IN orgid bigint, IN fromtimestamp character varying, IN totimestamp character varying,IN catalogId bigint, OUT rels t_rels[])
  RETURNS t_rels[] AS
$BODY$
DECLARE

	parentid RELATIONSHIP.PARENTID%TYPE;
	childid RELATIONSHIP.CHILDID%TYPE;
	
	childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	
	parentCatalogName CATALOG.NAME%TYPE;
	childCatalogName CATALOG.NAME%TYPE;
  
	productId varchar(255);
	productIdExt varchar(255);
  
	relationshipName RELATIONSHIPDEFINITION.NAME%TYPE;
  
	columnDataCount SMALLINT;
	sQuery text;
	l_Relationships RELATIONSHIP%ROWTYPE;
	rel T_RELS;
	k integer := 1;
BEGIN

    rel.parentId :='parentId';
	rel.parentIdExt :='parentIdExt';
	rel.parentVersion:=1;
	rel.parentCatalogName :='parentCatalogName';
	rel.childId :='childId';
	rel.childIdExt :='childIdExt';
	rel.childVersion :=1;
	rel.childCatalogName :='childCatalogName';
	rel.relationshipName :='relationshipName';
	rels[k] :=rel;
	k := k+1;
	
	IF fromtimestamp = NULL OR TRIM(fromtimestamp) = '' THEN
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE <= to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'' AND OWNERID='|| catalogId ||')';
	ELSE
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'' AND OWNERID = '|| catalogId ||' )';
	END IF;
	
	FOR l_relationships IN EXECUTE sQuery LOOP
		BEGIN
			RAISE NOTICE '%',k;
			SELECT DISTINCT RELATIONSHIPDEFINITION.OWNERID, CATALOG.NAME INTO parentCatalogId, parentCatalogName FROM RELATIONSHIPDEFINITION, CATALOG 
			WHERE RELATIONSHIPDEFINITION.ORGANIZATIONID = orgId AND RELATIONSHIPDEFINITION.TYPE = l_relationships.TYPE AND RELATIONSHIPDEFINITION.ACTIVE = 'Y'
			AND RELATIONSHIPDEFINITION.OWNERID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			RAISE NOTICE '%',parentCatalogId;
			RAISE NOTICE '%',l_relationships.PARENTID;
			RAISE NOTICE '%',l_relationships.PARENTVERSION;
			
			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.PARENTID  || ' AND CMODVERSION = ' || l_relationships.PARENTVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.PARENTID || ' AND CMODVERSION = ' || l_relationships.PARENTVERSION  INTO productIdExt ;
			

		
			RAISE NOTICE '%',productId;
			RAISE NOTICE '%',productIdExt;
			rel.parentId := productId;
			rel.parentIdExt := productIdExt;
			rel.parentVersion := l_relationships.PARENTVERSION;
			rel.parentCatalogName := parentCatalogName;

				SELECT DISTINCT TEMP1.CATID, CATALOG.NAME INTO childCatalogId, childCatalogName FROM CATALOG, 
			(SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
						ELSE TEMP.TARGETCATALOGID 
					END CATID FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relationships.TYPE AND ACTIVE = 'Y') TEMP) TEMP1
			WHERE TEMP1.CATID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.CHILDID  || ' AND CMODVERSION = ' || l_relationships.CHILDVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.CHILDID || ' AND CMODVERSION = ' || l_relationships.CHILDVERSION  INTO productIdExt ;
			
			rel.childId := productId;
			rel.childIdExt := productIdExt;
			rel.childVersion := l_relationships.CHILDVERSION;
			rel.childCatalogName := childCatalogName;

			SELECT NAME INTO relationshipName FROM RELATIONSHIPDEFINITION WHERE TYPE = l_relationships.TYPE AND ACTIVE = 'Y';

			rel.relationshipName := relationshipName;
			rels[k]=rel;
			k:=k+1;
		END; 
		     
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
CREATE TABLE LIFECYCLE_STATUS
(
	CPRODUCTKEYID BIGINT NOT NULL,
	CLIFECYCLESTATUS VARCHAR(256) NOT NULL, 
	TIMESTAMPFORMAT TIMESTAMP(6) NOT NULL
)
;
CREATE TABLE
---------------------------------------------------
Using PGHOME=/usr/pgsql-9.6
Using PGSQL=/usr/pgsql-9.6/bin/psql
Using PGPORT=35.193.59.186
Using PGPORT=5432
Using PGDATABASE=velodb
Using PGUSER=mdmuser
---------------------------------------------------
DO LANGUAGE plpgsql $$ 
DECLARE
 FUNC_ID smallint;
BEGIN
	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_sync';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_sync', 'FP Catalog Synchronization', 'catalogmenu_catalog_sync');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_publish';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_publish', 'Publish Catalog', 'catalogmenu_catalog_publish');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_fc_export';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_fc_export', 'Export FC Data', 'catalogmenu_catalog_fc_export');
	END IF;

	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_fc_import';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_fc_import', 'Import FC Data', 'catalogmenu_catalog_fc_import');
	END IF;
	
	SELECT COUNT(1) INTO FUNC_ID FROM FUNCTION WHERE NAME = 'catalogmenu_catalog_bulk_delete';
	IF FUNC_ID = 0 THEN 
		INSERT INTO FUNCTION ( ID, NAME, DESCRIPTION, FUNCTION)
		values ((select (max(id)+1)  from FUNCTION), 'catalogmenu_catalog_bulk_delete', 'Bulk Delete', 'catalogmenu_catalog_bulk_delete');
	END IF;	
	
END;
$$;
DO
/* Data for the `SCREEN` table  (Records 2001-...) */
DO LANGUAGE plpgsql $$ 
DECLARE
 SCREEN_ID smallint;
BEGIN
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '2001';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('2001', 'EN', 'FP Catalog Synchronization', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1102';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1102', 'EN', 'Publish Catalog', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1103';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1103', 'EN', 'Publish Catalog Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1104';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1104', 'EN', 'Export FC Data Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1105';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1105', 'EN', 'Import FC Data', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1106';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1106', 'EN', 'Import FC Data Status', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1107';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1107', 'EN', 'Export FC Data', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1111';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1111', 'EN', 'Hierarchy Management', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1113';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1113', 'EN', 'Delta Import', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1114';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1114', 'EN', 'Bulk Delete', NULL);
	END IF;
	
	SELECT COUNT(1) INTO SCREEN_ID FROM SCREEN WHERE SCREENID = '1115';
	IF SCREEN_ID = 0 THEN 
		INSERT INTO SCREEN(SCREENID, LANGUAGECODE, TITLE, HELPSCREENURL) VALUES ('1115', 'EN', 'Bulk Delete Status', NULL);
	END IF;	
END;
$$;
DO
DROP TYPE IF EXISTS T_RELEXTRACTOR_REC CASCADE;
DROP TYPE
DROP TYPE IF EXISTS T_COLUMNNAMES CASCADE;
DROP TYPE
DROP TYPE IF EXISTS T_EXTRACT_REC CASCADE;
DROP TYPE
CREATE TYPE T_RELEXTRACTOR_REC AS (
    relid NUMERIC(19),
	reltype NUMERIC(19)
);
CREATE TYPE
CREATE TYPE T_COLUMNNAMES AS(
	columnName VARCHAR(30)
);
CREATE TYPE
CREATE TYPE T_EXTRACT_REC AS(
	productKeyId BIGINT,
	catalogId BIGINT,
	modVersion BIGINT
);
CREATE TYPE
CREATE OR REPLACE FUNCTION fc_del_from_dbe_relationship(orgid bigint, reltablename character varying, mastertablename character varying, fromtimestamp character varying, totimestamp character varying)
  RETURNS void AS
$BODY$
	DECLARE 
		parent_id RELATIONSHIP.PARENTID%TYPE;
		parent_Version RELATIONSHIP.PARENTVERSION%TYPE;
		child_id RELATIONSHIP.CHILDID%TYPE;
		child_Version RELATIONSHIP.CHILDVERSION%TYPE;
		mod_date RELATIONSHIP.MODDATE%TYPE;
		
		previousModDate RELATIONSHIP.MODDATE%TYPE;
		previousRelationId DECIMAL(38) = NULL;
		
		rctTableName CATALOG.TABLENAME%TYPE;
		childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
		parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
		
		columnDataCount SMALLINT;
		
		l_relextractor T_RELEXTRACTOR_REC;
		l_columnanmes T_COLUMNNAMES;
		
		to_delete T_EXTRACT_REC [];
		to_retain T_EXTRACT_REC [];
	
		to_delete_counter INTEGER := 1;
		to_retain_counter INTEGER := 1;
	
		retain_flag BOOLEAN :=false;
		delete_flag BOOLEAN :=true;
  
		counter INTEGER := 0;

		to_delete_rec T_EXTRACT_REC;
		to_retain_rec T_EXTRACT_REC;
		
		hasDataChanged varchar(1);
		
	BEGIN
		FOR l_relextractor IN EXECUTE  'SELECT RELID, TYPE FROM ' || relTablename LOOP
			BEGIN
				hasDataChanged := 'N';
				delete_flag := false;
      
				
				SELECT DISTINCT 'rct_' || RELATIONSHIPCATALOGID  FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE = l_relextractor.reltype  AND ACTIVE = 'Y'  INTO rctTableName;
					
				SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
							ELSE TEMP.TARGETCATALOGID 
						END INTO childCatalogId FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relextractor.reltype AND ACTIVE = 'Y') TEMP;

				SELECT DISTINCT OWNERID INTO parentCatalogId FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relextractor.reltype AND ACTIVE = 'Y';

				SELECT PARENTID, PARENTVERSION, CHILDID, CHILDVERSION ,MODDATE INTO parent_id, parent_Version, child_id, child_Version,mod_date FROM RELATIONSHIP WHERE RELATIONID = l_relextractor.relid;
				IF mod_date >= to_timestamp(fromtimestamp,'YYYY-MM-DD HH24:mi:ss:MS') AND mod_date <= to_timestamp(totimestamp,'YYYY-MM-DD HH24:mi:ss:MS') THEN
				
					EXECUTE 'SELECT MAX(MODDATE) FROM RELATIONSHIP,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') PARENT,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') CHILD        WHERE PARENTID = ' || parent_id || ' AND CHILDID = ' || child_id || ' AND TYPE = ' || l_relextractor.reltype || ' AND MODDATE < to_timestamp(''' || mod_date || ''',''YYYY-MM-DD HH24:mi:ss:MS'') AND ACTIVE = ''Y'' AND PARENTID = PARENT.PRODUCTKEYID AND PARENTVERSION = PARENT.MODVERSION AND CHILDID = CHILD.PRODUCTKEYID AND CHILDVERSION = CHILD.MODVERSION' INTO previousModDate;	

					RAISE NOTICE 'previousModDate--%',previousModDate;
					
					IF previousModDate IS NOT NULL THEN
					
						EXECUTE 'SELECT RELATIONSHIP.RELATIONID FROM RELATIONSHIP,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') PARENT,(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE ACTIVE = ''Y'' AND STATE = ''CONFIRMED'') CHILD        WHERE PARENTID = ' || parent_id || ' AND CHILDID = ' || child_id || ' AND TYPE = ' || l_relextractor.reltype || ' AND MODDATE = to_timestamp(''' || previousModDate || ''',''YYYY-MM-DD HH24:mi:ss:MS'') AND ACTIVE = ''Y'' AND PARENTID = PARENT.PRODUCTKEYID AND PARENTVERSION = PARENT.MODVERSION AND CHILDID = CHILD.PRODUCTKEYID AND CHILDVERSION = CHILD.MODVERSION' INTO previousRelationId;
					
						RAISE NOTICE 'previousRelationId--%',previousRelationId;
					
					
						IF previousRelationId IS NOT NULL THEN
							FOR l_columnanmes IN EXECUTE  'SELECT COLUMN_NAME FROM information_schema.columns WHERE TABLE_NAME = ''' || rctTableName || '''' LOOP
								BEGIN
									IF l_columnanmes.columnName != 'CRELATIONID' AND l_columnanmes.columnName != 'crelationid'  THEN
										
										EXECUTE  'SELECT COUNT(*) FROM (SELECT DISTINCT ' || l_columnanmes.columnName || ' FROM ' || rctTableName || ' WHERE CRELATIONID IN (' || l_relextractor.relid || ',' || previousRelationId || ')) COLUMNNAMEALIAS' INTO columnDataCount;
            
										IF columnDataCount > 1 THEN
											RAISE NOTICE 'l_columnanmes.columnName%',l_columnanmes.columnName;
											hasDataChanged := 'Y';
										END IF;
									END IF;
								END;
							END LOOP;
						
							IF hasDataChanged = 'N' THEN
								RAISE NOTICE 'Deleting relationid--%',  l_relextractor.relid;
								EXECUTE  'DELETE FROM ' || relTablename || ' WHERE RELID = ' || l_relextractor.relid;

								to_delete_rec.productKeyId := parent_id;
								to_delete_rec.catalogId := parentCatalogId;
								to_delete_rec.modVersion := parent_Version;
								
								to_delete[to_delete_counter] := to_delete_rec;
								to_delete_counter := to_delete_counter+1;
							       
								to_delete_rec.productKeyId := child_id;
								to_delete_rec.catalogId := childCatalogId;
								to_delete_rec.modVersion := child_Version;
								
								to_delete[to_delete_counter] := to_delete_rec;
								to_delete_counter := to_delete_counter+1;

								delete_flag := true;
							END IF;
						END IF;
					
					
						IF not found then
							raise notice 'No data found';
						END IF;
					END IF;
				
				ELSE
					RAISE NOTICE 'deleting relationid--%',  l_relextractor.relid;
					
					EXECUTE  'DELETE FROM ' || relTablename || ' WHERE RELID = ' || l_relextractor.relid;
		   
					to_delete_rec.productKeyId := parent_id;
					to_delete_rec.catalogId := parentCatalogId;
					to_delete_rec.modVersion := parent_Version;
								
					to_delete[to_delete_counter] := to_delete_rec;
					to_delete_counter := to_delete_counter+1;
								
					to_delete_rec.productKeyId := child_id;
					to_delete_rec.catalogId := childCatalogId;
					to_delete_rec.modVersion := child_Version;

					to_delete[to_delete_counter] := to_delete_rec;
					to_delete_counter := to_delete_counter+1;
								
					delete_flag := true;
				END IF;
			
				IF NOT delete_flag THEN 
					to_retain_rec.productKeyId := parent_id;
					to_retain_rec.catalogId := parentCatalogId;
					to_retain_rec.modVersion := parent_Version;

					to_retain[to_retain_counter] := to_retain_rec;
					to_retain_counter := to_retain_counter+1;

					
					to_retain_rec.productKeyId := child_id;
					to_retain_rec.catalogId := childCatalogId;
					to_retain_rec.modVersion := child_Version;
					
					to_retain[to_retain_counter] := to_retain_rec;
					to_retain_counter := to_retain_counter+1;
				END IF;
			END;
		END LOOP;

		IF to_delete[1] IS NOT NULL THEN
		
			FOR j IN 1..array_upper(to_delete, 1) LOOP
				BEGIN       
					IF to_retain[1] IS NOT NULL THEN
						FOR k IN 1..array_upper(to_retain, 1) LOOP
							BEGIN
								IF to_delete[j].productKeyId = to_retain[k].productKeyId  AND to_delete[j].catalogId = to_retain[k].catalogId THEN
									retain_flag :=true;
									EXIT WHEN retain_flag;
								END IF;
							END;
						END LOOP;
					END IF;
	
      
					IF NOT retain_flag THEN
						Raise notice 'masterTableName--%--%',masterTableName,to_delete[j];
						EXECUTE  'DELETE FROM ' || masterTableName || to_delete[j].catalogId || ' WHERE PRODUCTKEYID = ' ||  to_delete[j].productKeyId || ' AND MODVERSION = ' || to_delete[j].modVersion|| ' AND PRODUCTKEYID NOT IN (SELECT PRODUCTKEYID FROM PRINCIPALKEY WHERE PRODUCTKEYID = ' || to_delete[j].productKeyId || ' AND ACTIVE = ''Y'' AND STATE = ''CONFIRMED'' AND MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss:MS'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss:MS''))';
					END IF;
         
					retain_flag :=false; 
				END;
			END LOOP;
		END IF;
	END;	
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
DROP TYPE IF EXISTS T_DELETED_RELS CASCADE;
DROP TYPE
CREATE  TYPE T_DELETED_RELS AS(
	parentId VARCHAR(255),
	parentIdExt VARCHAR(255),
	parentCatalogName VARCHAR(80),
	childId VARCHAR(255),
	childIdExt VARCHAR(255),
	childCatalogName VARCHAR(80),
	relationshipName VARCHAR(80)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION fc_get_deleted_relationship(IN orgid bigint, IN fromtimestamp character varying, IN totimestamp character varying, OUT deletedrels t_deleted_rels[])
  RETURNS t_deleted_rels[] AS
$BODY$
DECLARE

	parentid RELATIONSHIP.PARENTID%TYPE;
	childid RELATIONSHIP.CHILDID%TYPE;
	
	childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	
	parentCatalogName CATALOG.NAME%TYPE;
	childCatalogName CATALOG.NAME%TYPE;
  
	productId varchar(255);
	productIdExt varchar(255);
  
	relationshipName RELATIONSHIPDEFINITION.NAME%TYPE;
  
	columnDataCount SMALLINT;
	sQuery text;
	l_deletedRelationships RELATIONSHIP%ROWTYPE;
	deletedRel T_DELETED_RELS;
	k integer := 1;
BEGIN

    deletedRel.parentId :='parentId';
	deletedRel.parentIdExt :='parentIdExt';
	deletedRel.parentCatalogName :='parentCatalogName';
	deletedRel.childId :='childId';
	deletedRel.childIdExt :='childIdExt';
	deletedRel.childCatalogName :='childCatalogName';
	deletedRel.relationshipName :='relationshipName';
	deletedrels[k] :=deletedRel;
	k := k+1;
	
	IF fromtimestamp = NULL OR TRIM(fromtimestamp) = '' THEN
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE <= to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.ACTIVE = ''N'' 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'')';
	ELSE
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.ACTIVE = ''N'' 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'')';
	END IF;
	
	FOR l_deletedRelationships IN EXECUTE sQuery LOOP
		BEGIN
			RAISE NOTICE '%',k;
			SELECT DISTINCT RELATIONSHIPDEFINITION.OWNERID, CATALOG.NAME INTO parentCatalogId, parentCatalogName FROM RELATIONSHIPDEFINITION, CATALOG 
			WHERE RELATIONSHIPDEFINITION.ORGANIZATIONID = orgId AND RELATIONSHIPDEFINITION.TYPE = l_deletedRelationships.TYPE AND RELATIONSHIPDEFINITION.ACTIVE = 'Y'
			AND RELATIONSHIPDEFINITION.OWNERID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			RAISE NOTICE '%',parentCatalogId;
			RAISE NOTICE '%',l_deletedRelationships.PARENTID;
			RAISE NOTICE '%',l_deletedRelationships.PARENTVERSION;
			
			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.PARENTID  || ' AND CMODVERSION = ' || l_deletedRelationships.PARENTVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.PARENTID || ' AND CMODVERSION = ' || l_deletedRelationships.PARENTVERSION  INTO productIdExt ;
			

		
			RAISE NOTICE '%',productId;
			RAISE NOTICE '%',productIdExt;
			deletedRel.parentId := productId;
			deletedRel.parentIdExt := productIdExt;
			deletedRel.parentCatalogName := parentCatalogName;

				SELECT DISTINCT TEMP1.CATID, CATALOG.NAME INTO childCatalogId, childCatalogName FROM CATALOG, 
			(SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
						ELSE TEMP.TARGETCATALOGID 
					END CATID FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_deletedRelationships.TYPE AND ACTIVE = 'Y') TEMP) TEMP1
			WHERE TEMP1.CATID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.CHILDID  || ' AND CMODVERSION = ' || l_deletedRelationships.CHILDVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_deletedRelationships.CHILDID || ' AND CMODVERSION = ' || l_deletedRelationships.CHILDVERSION  INTO productIdExt ;
			
			deletedRel.childId := productId;
			deletedRel.childIdExt := productIdExt;
			deletedRel.childCatalogName := childCatalogName;

			SELECT NAME INTO relationshipName FROM RELATIONSHIPDEFINITION WHERE TYPE = l_deletedRelationships.TYPE AND ACTIVE = 'Y';

			deletedRel.relationshipName := relationshipName;
			deletedRels[k]=deletedRel;
			k:=k+1;
		END; 
		     
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
drop trigger IF EXISTS FC_TU_PROCESS ON PROCESS;
DROP TRIGGER
CREATE OR REPLACE FUNCTION updateworkitem()
  RETURNS trigger AS
$BODY$DECLARE
   processId_ PROCESS.ID%TYPE;
   plCount BIGINT;
BEGIN 
   processId_ := OLD.ID;

   SELECT COUNT(*) INTO plCount FROM PROCESSLOG WHERE PROCESSID = processId_ AND LOWER(ACTION) = 'fcextractdatatodelimitedfile';
   
   IF plCount > 0 THEN
   
       NEW.status := 'WAIT-TASK';
       
   END IF;

  RETURN NEW;
    
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
CREATE TRIGGER FC_TU_PROCESS BEFORE UPDATE OF STATUS ON PROCESS 
FOR EACH ROW WHEN (NEW.STATUS = 'WAIT-WORKITEM') EXECUTE PROCEDURE updateworkitem();
CREATE TRIGGER
CREATE OR REPLACE FUNCTION fc_updatelifecyclestatus_pkg_get_record(witemid character varying)
  RETURNS void AS
$BODY$
DECLARE 

	catalogId WORKITEMDETAIL.VALUE%TYPE;
	productKeyId WORKITEMDETAIL.VALUE%TYPE;
	productVersion WORKITEMDETAIL.VALUE%TYPE;
	recordCount DECIMAL(10);
	sQuery VARCHAR(1000);
	sPreviousStatus VARCHAR(100);
BEGIN
		
	SELECT WORKITEMDETAIL.VALUE INTO catalogId FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND WORKITEMDETAIL.NAME = 'MASTERCATALOGID';
						
	SELECT WORKITEMDETAIL.VALUE INTO productKeyId FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'PRODUCTKEYID';
				
	SELECT WORKITEMDETAIL.VALUE INTO productVersion FROM WORKITEM, WORKITEMDETAIL
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'PRODUCTVERSION';


	
	EXECUTE 'SELECT clifecyclestatus as varchar FROM MCT_' || catalogId || ' WHERE CPRODUCTKEYID = ' || to_number(productKeyId) || ' AND CMODVERSION = ' || to_number(productVersion)  INTO sPreviousStatus;
	  
	IF sPreviousStatus IS NULL OR TRIM(sPreviousStatus) = '' THEN
		sPreviousStatus := 'TESTING';
	END IF;
  
	DELETE FROM LIFECYCLE_STATUS WHERE CPRODUCTKEYID = to_number(productKeyId);
	INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (to_number(productKeyId), sPreviousStatus , CURRENT_TIMESTAMP);
	INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (to_number(productKeyId), 'PENDINGAPPROVAL' , CURRENT_TIMESTAMP);  
	
	EXECUTE 'UPDATE MCT_' || catalogId || ' SET CLIFECYCLESTATUS = ''PENDINGAPPROVAL'' WHERE CPRODUCTKEYID = ' || to_number(productKeyId) || ' AND CMODVERSION = ' || to_number(productVersion) ;
	
	SELECT WORKITEMDETAIL.VALUE INTO recordCount FROM WORKITEM, WORKITEMDETAIL 
	WHERE WORKITEMDETAIL.WORKITEMID = WORKITEM.ID
	AND WORKITEM.ID = to_number(wItemId)
	AND WORKITEM.ACTIVITYNAME IN ('InternalEditWorkItem', 'InternalApprovalWorkItemModify', 'InternalApprovalWorkItemDelete')
	AND NAME = 'RECORD_COUNT';
	
	IF recordCount > 1 THEN
		PERFORM FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(productKeyId, productVersion,catalogId);
	END IF;
END;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;
CREATE FUNCTION
DROP TYPE IF EXISTS T_CHILDRECORDS CASCADE;
DROP TYPE
CREATE  TYPE T_CHILDRECORDS AS(
	childid varchar(4000),
    childVersion varchar(4000)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION  FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(productKeyId IN WORKITEMDETAIL.VALUE%TYPE, productVersion IN WORKITEMDETAIL.VALUE%TYPE, catalogId IN WORKITEMDETAIL.VALUE%TYPE) RETURNS VOID AS
$BODY$
DECLARE 
    l_children T_CHILDRECORDS;
    sQuery VARCHAR(1000);
    sPreviousStatus VARCHAR(100);
BEGIN

	FOR l_children IN EXECUTE 'SELECT CHILDID, CHILDVERSION FROM RELATIONSHIP WHERE PARENTID =' || productKeyId || 'AND PARENTVERSION =' || productVersion || 'AND OWNERID =' || catalogId || 'AND CHILDOWNERID = '|| catalogId LOOP
		
		EXECUTE 'SELECT clifecyclestatus as varchar FROM MCT_' || catalogId || ' WHERE CPRODUCTKEYID = ' || l_children.childid || ' AND CMODVERSION = ' || l_children.childVersion INTO sPreviousStatus;
				
			IF sPreviousStatus IS NULL OR TRIM(sPreviousStatus) = '' THEN
				sPreviousStatus := 'TESTING';
			END IF;		
		  
			DELETE FROM LIFECYCLE_STATUS WHERE CPRODUCTKEYID = l_children.childid;
			INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (l_children.childid, sPreviousStatus , CURRENT_TIMESTAMP);
			INSERT INTO LIFECYCLE_STATUS (CPRODUCTKEYID, CLIFECYCLESTATUS, TIMESTAMPFORMAT) VALUES (l_children.childid, 'PENDINGAPPROVAL' , CURRENT_TIMESTAMP);
		
		EXECUTE 'UPDATE MCT_' || catalogId || ' SET CLIFECYCLESTATUS = ''PENDINGAPPROVAL'' WHERE CPRODUCTKEYID = ' || l_children.childid || ' AND CMODVERSION = ' || l_children.childVersion;
		PERFORM FC_UPDATELIFECYCLESTATUS_PKG_UPDATE_LIFECYCLESTATUS(l_children.childid, l_children.childVersion, catalogId);
	END LOOP;

END;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION ClearNamedVersionData(ORG_NAME varchar(80)) RETURNS VOID AS $$
	DECLARE
		idOrganization ORGANIZATION.ID%TYPE;
	BEGIN
	
		RAISE NOTICE 'Organization Name:%',ORG_NAME;
		SELECT ID INTO idOrganization FROM ORGANIZATION WHERE lower(name) = lower(ORG_NAME);
		RAISE NOTICE 'Enterprise Id:%',idOrganization;

		DELETE FROM NAMEDVERSION WHERE OWNERID IN (SELECT ID FROM CATALOG WHERE SOURCEORGANIZATIONID = idOrganization AND TYPE = 'CATALOG' AND ACTIVE = 'Y');
		DELETE FROM NAMEDVERSION WHERE OWNERID = idOrganization;
	
		IF NOT FOUND THEN
			RAISE NOTICE 'No data found';
		END IF;
	END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
DROP TYPE IF EXISTS T_RELS CASCADE;
DROP TYPE
CREATE TYPE T_RELS AS(
	parentId VARCHAR(255),
	parentIdExt VARCHAR(255),
	parentVersion bigint,
	parentCatalogName VARCHAR(80),
	childId VARCHAR(255),
	childIdExt VARCHAR(255),
	childVersion bigint,
	childCatalogName VARCHAR(80),
	relationshipName VARCHAR(80)
);
CREATE TYPE
CREATE OR REPLACE FUNCTION FC_GET_REL_DEL_MOD_IN_TS(IN orgid bigint, IN fromtimestamp character varying, IN totimestamp character varying,IN catalogId bigint, OUT rels t_rels[])
  RETURNS t_rels[] AS
$BODY$
DECLARE

	parentid RELATIONSHIP.PARENTID%TYPE;
	childid RELATIONSHIP.CHILDID%TYPE;
	
	childCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	parentCatalogId RELATIONSHIPDEFINITION.OWNERID%TYPE;
	
	parentCatalogName CATALOG.NAME%TYPE;
	childCatalogName CATALOG.NAME%TYPE;
  
	productId varchar(255);
	productIdExt varchar(255);
  
	relationshipName RELATIONSHIPDEFINITION.NAME%TYPE;
  
	columnDataCount SMALLINT;
	sQuery text;
	l_Relationships RELATIONSHIP%ROWTYPE;
	rel T_RELS;
	k integer := 1;
BEGIN

    rel.parentId :='parentId';
	rel.parentIdExt :='parentIdExt';
	rel.parentVersion:=1;
	rel.parentCatalogName :='parentCatalogName';
	rel.childId :='childId';
	rel.childIdExt :='childIdExt';
	rel.childVersion :=1;
	rel.childCatalogName :='childCatalogName';
	rel.relationshipName :='relationshipName';
	rels[k] :=rel;
	k := k+1;
	
	IF fromtimestamp = NULL OR TRIM(fromtimestamp) = '' THEN
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE <= to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') 
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'' AND OWNERID='|| catalogId ||')';
	ELSE
		sQuery := 'SELECT RELATIONSHIP.* FROM RELATIONSHIP, 
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') PARENT,
		(SELECT PRODUCTKEYID, MODVERSION FROM PRINCIPALKEY WHERE STATE = ''CONFIRMED'') CHILD
		
		WHERE RELATIONSHIP.MODDATE BETWEEN to_timestamp(''' || fromtimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'') AND to_timestamp(''' || totimestamp || ''', ''YYYY-MM-DD HH24:mi:ss'')
		AND RELATIONSHIP.PARENTID = PARENT.PRODUCTKEYID
		AND RELATIONSHIP.PARENTVERSION = PARENT.MODVERSION
		AND RELATIONSHIP.CHILDID = CHILD.PRODUCTKEYID
		AND RELATIONSHIP.CHILDVERSION = CHILD.MODVERSION
		AND TYPE IN (SELECT DISTINCT TYPE FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = ' || orgId || ' AND ACTIVE = ''Y'' AND OWNERID = '|| catalogId ||' )';
	END IF;
	
	FOR l_relationships IN EXECUTE sQuery LOOP
		BEGIN
			RAISE NOTICE '%',k;
			SELECT DISTINCT RELATIONSHIPDEFINITION.OWNERID, CATALOG.NAME INTO parentCatalogId, parentCatalogName FROM RELATIONSHIPDEFINITION, CATALOG 
			WHERE RELATIONSHIPDEFINITION.ORGANIZATIONID = orgId AND RELATIONSHIPDEFINITION.TYPE = l_relationships.TYPE AND RELATIONSHIPDEFINITION.ACTIVE = 'Y'
			AND RELATIONSHIPDEFINITION.OWNERID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			RAISE NOTICE '%',parentCatalogId;
			RAISE NOTICE '%',l_relationships.PARENTID;
			RAISE NOTICE '%',l_relationships.PARENTVERSION;
			
			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.PARENTID  || ' AND CMODVERSION = ' || l_relationships.PARENTVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || parentCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.PARENTID || ' AND CMODVERSION = ' || l_relationships.PARENTVERSION  INTO productIdExt ;
			

		
			RAISE NOTICE '%',productId;
			RAISE NOTICE '%',productIdExt;
			rel.parentId := productId;
			rel.parentIdExt := productIdExt;
			rel.parentVersion := l_relationships.PARENTVERSION;
			rel.parentCatalogName := parentCatalogName;

				SELECT DISTINCT TEMP1.CATID, CATALOG.NAME INTO childCatalogId, childCatalogName FROM CATALOG, 
			(SELECT 
					CASE
						WHEN TEMP.TARGETCATALOGID = -1 THEN TEMP.OWNERID
						ELSE TEMP.TARGETCATALOGID 
					END CATID FROM (SELECT DISTINCT OWNERID, TARGETCATALOGID FROM RELATIONSHIPDEFINITION WHERE ORGANIZATIONID = orgId AND TYPE =  l_relationships.TYPE AND ACTIVE = 'Y') TEMP) TEMP1
			WHERE TEMP1.CATID = CATALOG.ID AND CATALOG.ACTIVE = 'Y';

			EXECUTE 'SELECT CPRODUCTID as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.CHILDID  || ' AND CMODVERSION = ' || l_relationships.CHILDVERSION INTO productId ;
			EXECUTE 'SELECT CPRODUCTIDEXT as varchar FROM MCT_' || childCatalogId || ' WHERE CPRODUCTKEYID = ' || l_relationships.CHILDID || ' AND CMODVERSION = ' || l_relationships.CHILDVERSION  INTO productIdExt ;
			
			rel.childId := productId;
			rel.childIdExt := productIdExt;
			rel.childVersion := l_relationships.CHILDVERSION;
			rel.childCatalogName := childCatalogName;

			SELECT NAME INTO relationshipName FROM RELATIONSHIPDEFINITION WHERE TYPE = l_relationships.TYPE AND ACTIVE = 'Y';

			rel.relationshipName := relationshipName;
			rels[k]=rel;
			k:=k+1;
		END; 
		     
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
CREATE TABLE LIFECYCLE_STATUS
(
	CPRODUCTKEYID BIGINT NOT NULL,
	CLIFECYCLESTATUS VARCHAR(256) NOT NULL, 
	TIMESTAMPFORMAT TIMESTAMP(6) NOT NULL
)
;
CREATE TABLE
